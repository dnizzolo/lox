(in-package #:lox.ast)

(export 'print-ast)
(defgeneric print-ast (object &optional stream))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun expand-ast (name kind slots)
    (let* ((keywords (mapcar #'a:make-keyword slots))
           (keyargs (mapcan #'list keywords slots))
           (name-string (string name))
           (constructor (intern (concatenate 'string "MAKE-" name-string)))
           (predicate (intern (concatenate 'string name-string "-P"))))
      `(progn
         (export ',name)
         (export ',slots)
         (export ',constructor)
         (export ',predicate)
         (defclass ,name (,kind)
           (,@(mapcar (lambda (slot keyword) (list slot :initarg keyword :accessor slot))
                      slots keywords))
           (:default-initargs
            ,@(mapcan (lambda (keyword) (list keyword `(a:required-argument ,keyword)))
                      keywords)))
         (defun ,constructor ,slots
           (make-instance ',name ,@keyargs))
         (defun ,predicate (object)
           (typep object ',name))
         (defmethod print-object ((object ,name) stream)
           (with-slots ,slots object
             (print-unreadable-object (object stream :type t :identity t)
               (format stream "~{~a~^ ~}" (list ,@keyargs)))))
         (defmethod print-ast ((object ,name) &optional (stream *standard-output*))
           (with-slots ,slots object
             (loop initially (write-char #\( stream)
                             (princ ',name stream)
                   for slot in (list ,@slots)
                   do (write-char #\Space stream)
                      (cl:cond ((or (expr-p slot) (stmt-p slot))
                                (print-ast slot stream))
                               ((lox.token:token-p slot)
                                (prin1 (lox.token:lexeme slot)))
                               ((cl:vectorp slot)
                                (cl:if (a:emptyp slot)
                                       (princ "()" stream)
                                       (map nil (lambda (e) (print-ast e stream)) slot)))
                               (t (princ slot stream)))
                   finally (write-char #\) stream))))))))

(defclass expr () ())

(export 'expr-p)
(defun expr-p (object)
  (typep object 'expr))

(defmacro define-expr (name slots)
  (expand-ast name 'expr slots))

(define-expr assign (name value))
(define-expr binary (left operator right))
(define-expr call (callee token arguments))
(define-expr get (object name))
(define-expr grouping (expression))
(define-expr literal (value))
(define-expr logical (left operator right))
(define-expr set (object name value))
(define-expr super (token method))
(define-expr ternary (condition consequent alternative))
(define-expr this (token))
(define-expr unary (operator right))
(define-expr variable (name))

(defclass stmt () ())

(export 'stmt-p)
(defun stmt-p (object)
  (typep object 'stmt))

(defmacro define-stmt (name slots)
  (expand-ast name 'stmt slots))

(define-stmt block (statements))
(define-stmt class (name superclass methods))
(define-stmt expression (expression))
(define-stmt function (name params body))
(define-stmt if (condition then-branch else-branch))
(define-stmt print (expression))
(define-stmt return (token value))
(define-stmt var (name initializer))
(define-stmt while (condition body))
